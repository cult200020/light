local library = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))()

local w1 = library:Window("snippet.cc ESP Menu") -- Text


-- Made by Blissful#4992, toggle/cleanup by Copilot

local Players = game:service("Players")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:service("Workspace").CurrentCamera
local RS = game:service("RunService")
local UIS = game:service("UserInputService")

repeat wait() until Player.Character ~= nil and Player.Character.PrimaryPart ~= nil

local LerpColorModule = loadstring(game:HttpGet("https://pastebin.com/raw/wRnsJeid"))()
local HealthBarLerp = LerpColorModule:Lerp(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0))

-- TRACKING TABLES
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}
local ESP_ON = false

local RadarInfo = {
    Position = Vector2.new(200, 200),
    Radius = 100,
    Scale = 1,
    RadarBack = Color3.fromRGB(10, 10, 10),
    RadarBorder = Color3.fromRGB(75, 75, 75),
    LocalPlayerDot = Color3.fromRGB(255, 255, 255),
    PlayerDot = Color3.fromRGB(60, 170, 255),
    Team = Color3.fromRGB(0, 255, 0),
    Enemy = Color3.fromRGB(255, 0, 0),
    Health_Color = true,
    Team_Check = true
}

local function NewCircle(Transparency, Color, Radius, Filled, Thickness)
    local c = Drawing.new("Circle")
    c.Transparency = Transparency
    c.Color = Color
    c.Visible = false
    c.Thickness = Thickness
    c.Position = Vector2.new(0, 0)
    c.Radius = Radius
    c.NumSides = math.clamp(Radius*55/100, 10, 75)
    c.Filled = Filled
    table.insert(ALL_DRAWINGS, c)
    return c
end

local function NewTriangle()
    local d = Drawing.new("Triangle")
    d.Visible = true
    d.Thickness = 1
    d.Filled = true
    d.Color = RadarInfo.LocalPlayerDot
    d.PointA = RadarInfo.Position + Vector2.new(0, -6)
    d.PointB = RadarInfo.Position + Vector2.new(-3, 6)
    d.PointC = RadarInfo.Position + Vector2.new(3, 6)
    table.insert(ALL_DRAWINGS, d)
    return d
end

local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
end

local function GetRelative(pos)
    local char = Player.Character
    if char ~= nil and char.PrimaryPart ~= nil then
        local pmpart = char.PrimaryPart
        local camerapos = Vector3.new(Camera.CFrame.Position.X, pmpart.Position.Y, Camera.CFrame.Position.Z)
        local newcf = CFrame.new(pmpart.Position, camerapos)
        local r = newcf:PointToObjectSpace(pos)
        return r.X, r.Z
    else
        return 0, 0
    end
end

local function PlaceDot(plr)
    local PlayerDot = NewCircle(1, RadarInfo.PlayerDot, 3, true, 1)
    local function Update()
        local c 
        c = RS.RenderStepped:Connect(function()
            if not ESP_ON then
                PlayerDot.Visible = false
                if c then c:Disconnect() end
                return
            end
            local char = plr.Character
            if char and char:FindFirstChildOfClass("Humanoid") and char.PrimaryPart ~= nil and char:FindFirstChildOfClass("Humanoid").Health > 0 then
                local hum = char:FindFirstChildOfClass("Humanoid")
                local scale = RadarInfo.Scale
                local relx, rely = GetRelative(char.PrimaryPart.Position)
                local newpos = RadarInfo.Position - Vector2.new(relx * scale, rely * scale) 
                if (newpos - RadarInfo.Position).magnitude < RadarInfo.Radius-2 then 
                    PlayerDot.Radius = 3   
                    PlayerDot.Position = newpos
                    PlayerDot.Visible = true
                else 
                    local dist = (RadarInfo.Position - newpos).magnitude
                    local calc = (RadarInfo.Position - newpos).unit * (dist - RadarInfo.Radius)
                    local inside = Vector2.new(newpos.X + calc.X, newpos.Y + calc.Y)
                    PlayerDot.Radius = 2
                    PlayerDot.Position = inside
                    PlayerDot.Visible = true
                end

                PlayerDot.Color = RadarInfo.PlayerDot
                if RadarInfo.Team_Check then
                    if plr.TeamColor == Player.TeamColor then
                        PlayerDot.Color = RadarInfo.Team
                    else
                        PlayerDot.Color = RadarInfo.Enemy
                    end
                end

                if RadarInfo.Health_Color then
                    PlayerDot.Color = HealthBarLerp(hum.Health / hum.MaxHealth)
                end
            else 
                PlayerDot.Visible = false
                if Players:FindFirstChild(plr.Name) == nil then
                    PlayerDot:Remove()
                    if c then c:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, c)
    end
    coroutine.wrap(Update)()
end

local RadarBackground, RadarBorder, LocalPlayerDot

local function NewLocalDot()
    if LocalPlayerDot then pcall(function() LocalPlayerDot:Remove() end) end
    LocalPlayerDot = NewTriangle()
    return LocalPlayerDot
end

local function startESP()
    cleanupESP()

    RadarBackground = NewCircle(0.9, RadarInfo.RadarBack, RadarInfo.Radius, true, 1)
    RadarBackground.Visible = true
    RadarBackground.Position = RadarInfo.Position

    RadarBorder = NewCircle(0.75, RadarInfo.RadarBorder, RadarInfo.Radius, false, 3)
    RadarBorder.Visible = true
    RadarBorder.Position = RadarInfo.Position

    LocalPlayerDot = NewLocalDot()

    for _,v in pairs(Players:GetChildren()) do
        if v.Name ~= Player.Name then
            PlaceDot(v)
        end
    end

    local conn1 = Players.PlayerAdded:Connect(function(v)
        if v.Name ~= Player.Name then
            PlaceDot(v)
        end
        NewLocalDot()
    end)
    table.insert(ALL_CONNECTIONS, conn1)

    local conn2 = RS.RenderStepped:Connect(function()
        if not ESP_ON then
            if LocalPlayerDot then LocalPlayerDot.Visible = false end
            if RadarBackground then RadarBackground.Visible = false end
            if RadarBorder then RadarBorder.Visible = false end
            return
        end
        if LocalPlayerDot then
            LocalPlayerDot.Color = RadarInfo.LocalPlayerDot
            LocalPlayerDot.PointA = RadarInfo.Position + Vector2.new(0, -6)
            LocalPlayerDot.PointB = RadarInfo.Position + Vector2.new(-3, 6)
            LocalPlayerDot.PointC = RadarInfo.Position + Vector2.new(3, 6)
            LocalPlayerDot.Visible = true
        end
        if RadarBackground then
            RadarBackground.Position = RadarInfo.Position
            RadarBackground.Radius = RadarInfo.Radius
            RadarBackground.Color = RadarInfo.RadarBack
            RadarBackground.Visible = true
        end
        if RadarBorder then
            RadarBorder.Position = RadarInfo.Position
            RadarBorder.Radius = RadarInfo.Radius
            RadarBorder.Color = RadarInfo.RadarBorder
            RadarBorder.Visible = true
        end
    end)
    table.insert(ALL_CONNECTIONS, conn2)

    -- Draggable
    local inset = game:service("GuiService"):GetGuiInset()
    local dragging = false
    local offset = Vector2.new(0, 0)
    local conn3 = UIS.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
            offset = RadarInfo.Position - Vector2.new(Mouse.X, Mouse.Y)
            dragging = true
        end
    end)
    table.insert(ALL_CONNECTIONS, conn3)

    local conn4 = UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    table.insert(ALL_CONNECTIONS, conn4)

    local dot = NewCircle(1, Color3.fromRGB(255, 255, 255), 3, true, 1)
    local conn5 = RS.RenderStepped:Connect(function()
        if not ESP_ON then
            dot.Visible = false
            return
        end
        if (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
            dot.Position = Vector2.new(Mouse.X, Mouse.Y + inset.Y)
            dot.Visible = true
        else 
            dot.Visible = false
        end
        if dragging then
            RadarInfo.Position = Vector2.new(Mouse.X, Mouse.Y) + offset
        end
    end)
    table.insert(ALL_CONNECTIONS, conn5)
end

--// Toggle integration (Replace with your toggle UI if needed)
w1:Toggle(
    "Radar ESP", -- Button Text
    "radar_esp_flag", -- Unique flag
    false,
    function(toggled)
        ESP_ON = toggled
        if ESP_ON then
            startESP()
        else
            cleanupESP()
        end
    end
)



-- Health Bar ESP (toggle/cleanup support, no feature/visual changes)
-- Original by Blissful#4992, cleanup/toggle by Copilot

local Settings = {
    -- Only health bar settings needed
}

local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

-- Tracking tables and toggle state
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}
local ESP_ON = false

local function NewLine(thickness, color)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color 
    line.Thickness = thickness
    line.Transparency = 1
    table.insert(ALL_DRAWINGS, line)
    return line
end

local black = Color3.fromRGB(0, 0 ,0)

local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
end

local function ESP(plr)
    local library = {
        healthbar = NewLine(3, black),           -- background bar
        greenhealth = NewLine(1.5, black)        -- colored health portion
    }

    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESP_ON then
                library.healthbar.Visible = false
                library.greenhealth.Visible = false
                if connection then connection:Disconnect() end
                return
            end
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if OnScreen then
                    local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                    local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)

                    -- Health Bar calculation
                    local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                    local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d

                    library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)

                    library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)

                    local green = Color3.fromRGB(0, 255, 0)
                    local red = Color3.fromRGB(255, 0, 0)
                    library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);

                    library.healthbar.Visible = true
                    library.greenhealth.Visible = true
                else 
                    library.healthbar.Visible = false
                    library.greenhealth.Visible = false
                end
            else 
                library.healthbar.Visible = false
                library.greenhealth.Visible = false
                if game.Players:FindFirstChild(plr.Name) == nil then
                    if connection then connection:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, connection)
    end
    coroutine.wrap(Updater)()
end

local function startESP()
    cleanupESP()
    for i, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= player.Name then
            ESP(v)
        end
    end
    local conn = game.Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= player.Name then
            ESP(newplr)
        end
    end)
    table.insert(ALL_CONNECTIONS, conn)
end

--// Toggle integration (replace w1:Toggle with your UI if needed)
w1:Toggle(
    "Health Bar ESP", -- Button Text
    "healthbar_esp_flag", -- Unique flag
    false,
    function(toggled)
        ESP_ON = toggled
        if ESP_ON then
            startESP()
        else
            cleanupESP()
        end
    end
)

-- Skeleton ESP (R6/R15) with Toggle and Guaranteed Full Cleanup
-- Toggle with w1:Toggle; all lines instantly disappear on disable

local Player = game:GetService("Players").LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera

-- Track all Drawing objects & connections globally
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}

-- Toggle state
local ESP_ON = false

local function DrawLine()
    local l = Drawing.new("Line")
    l.Visible = false
    l.From = Vector2.new(0, 0)
    l.To = Vector2.new(1, 1)
    l.Color = Color3.fromRGB(255, 0, 0)
    l.Thickness = 1
    l.Transparency = 1
    table.insert(ALL_DRAWINGS, l)
    return l
end

local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
end

local function DrawESP(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    local limbs = {}
    local R15 = (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15)
    if R15 then 
        limbs = {
            Head_UpperTorso = DrawLine(),
            UpperTorso_LowerTorso = DrawLine(),
            UpperTorso_LeftUpperArm = DrawLine(),
            LeftUpperArm_LeftLowerArm = DrawLine(),
            LeftLowerArm_LeftHand = DrawLine(),
            UpperTorso_RightUpperArm = DrawLine(),
            RightUpperArm_RightLowerArm = DrawLine(),
            RightLowerArm_RightHand = DrawLine(),
            LowerTorso_LeftUpperLeg = DrawLine(),
            LeftUpperLeg_LeftLowerLeg = DrawLine(),
            LeftLowerLeg_LeftFoot = DrawLine(),
            LowerTorso_RightUpperLeg = DrawLine(),
            RightUpperLeg_RightLowerLeg = DrawLine(),
            RightLowerLeg_RightFoot = DrawLine(),
        }
    else 
        limbs = {
            Head_Spine = DrawLine(),
            Spine = DrawLine(),
            LeftArm = DrawLine(),
            LeftArm_UpperTorso = DrawLine(),
            RightArm = DrawLine(),
            RightArm_UpperTorso = DrawLine(),
            LeftLeg = DrawLine(),
            LeftLeg_LowerTorso = DrawLine(),
            RightLeg = DrawLine(),
            RightLeg_LowerTorso = DrawLine()
        }
    end
    local function Visibility(state)
        for _, v in pairs(limbs) do
            v.Visible = state
        end
    end

    local function UpdaterR15()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESP_ON then
                Visibility(false)
                if connection then connection:Disconnect() end
                return
            end
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    local UT = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                    local LT = Camera:WorldToViewportPoint(plr.Character.LowerTorso.Position)
                    local LUA = Camera:WorldToViewportPoint(plr.Character.LeftUpperArm.Position)
                    local LLA = Camera:WorldToViewportPoint(plr.Character.LeftLowerArm.Position)
                    local LH = Camera:WorldToViewportPoint(plr.Character.LeftHand.Position)
                    local RUA = Camera:WorldToViewportPoint(plr.Character.RightUpperArm.Position)
                    local RLA = Camera:WorldToViewportPoint(plr.Character.RightLowerArm.Position)
                    local RH = Camera:WorldToViewportPoint(plr.Character.RightHand.Position)
                    local LUL = Camera:WorldToViewportPoint(plr.Character.LeftUpperLeg.Position)
                    local LLL = Camera:WorldToViewportPoint(plr.Character.LeftLowerLeg.Position)
                    local LF = Camera:WorldToViewportPoint(plr.Character.LeftFoot.Position)
                    local RUL = Camera:WorldToViewportPoint(plr.Character.RightUpperLeg.Position)
                    local RLL = Camera:WorldToViewportPoint(plr.Character.RightLowerLeg.Position)
                    local RF = Camera:WorldToViewportPoint(plr.Character.RightFoot.Position)
                    
                    limbs.Head_UpperTorso.From = Vector2.new(H.X, H.Y)
                    limbs.Head_UpperTorso.To = Vector2.new(UT.X, UT.Y)
                    limbs.UpperTorso_LowerTorso.From = Vector2.new(UT.X, UT.Y)
                    limbs.UpperTorso_LowerTorso.To = Vector2.new(LT.X, LT.Y)
                    limbs.UpperTorso_LeftUpperArm.From = Vector2.new(UT.X, UT.Y)
                    limbs.UpperTorso_LeftUpperArm.To = Vector2.new(LUA.X, LUA.Y)
                    limbs.LeftUpperArm_LeftLowerArm.From = Vector2.new(LUA.X, LUA.Y)
                    limbs.LeftUpperArm_LeftLowerArm.To = Vector2.new(LLA.X, LLA.Y)
                    limbs.LeftLowerArm_LeftHand.From = Vector2.new(LLA.X, LLA.Y)
                    limbs.LeftLowerArm_LeftHand.To = Vector2.new(LH.X, LH.Y)
                    limbs.UpperTorso_RightUpperArm.From = Vector2.new(UT.X, UT.Y)
                    limbs.UpperTorso_RightUpperArm.To = Vector2.new(RUA.X, RUA.Y)
                    limbs.RightUpperArm_RightLowerArm.From = Vector2.new(RUA.X, RUA.Y)
                    limbs.RightUpperArm_RightLowerArm.To = Vector2.new(RLA.X, RLA.Y)
                    limbs.RightLowerArm_RightHand.From = Vector2.new(RLA.X, RLA.Y)
                    limbs.RightLowerArm_RightHand.To = Vector2.new(RH.X, RH.Y)
                    limbs.LowerTorso_LeftUpperLeg.From = Vector2.new(LT.X, LT.Y)
                    limbs.LowerTorso_LeftUpperLeg.To = Vector2.new(LUL.X, LUL.Y)
                    limbs.LeftUpperLeg_LeftLowerLeg.From = Vector2.new(LUL.X, LUL.Y)
                    limbs.LeftUpperLeg_LeftLowerLeg.To = Vector2.new(LLL.X, LLL.Y)
                    limbs.LeftLowerLeg_LeftFoot.From = Vector2.new(LLL.X, LLL.Y)
                    limbs.LeftLowerLeg_LeftFoot.To = Vector2.new(LF.X, LF.Y)
                    limbs.LowerTorso_RightUpperLeg.From = Vector2.new(LT.X, LT.Y)
                    limbs.LowerTorso_RightUpperLeg.To = Vector2.new(RUL.X, RUL.Y)
                    limbs.RightUpperLeg_RightLowerLeg.From = Vector2.new(RUL.X, RUL.Y)
                    limbs.RightUpperLeg_RightLowerLeg.To = Vector2.new(RLL.X, RLL.Y)
                    limbs.RightLowerLeg_RightFoot.From = Vector2.new(RLL.X, RLL.Y)
                    limbs.RightLowerLeg_RightFoot.To = Vector2.new(RF.X, RF.Y)
                    Visibility(true)
                else 
                    Visibility(false)
                end
            else 
                Visibility(false)
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for _, v in pairs(limbs) do pcall(function() v:Remove() end) end
                    if connection then connection:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, connection)
    end

    local function UpdaterR6()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESP_ON then
                Visibility(false)
                if connection then connection:Disconnect() end
                return
            end
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    local T_Height = plr.Character.Torso.Size.Y/2 - 0.2
                    local UT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, T_Height, 0)).p)
                    local LT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, -T_Height, 0)).p)
                    local LA_Height = plr.Character["Left Arm"].Size.Y/2 - 0.2
                    local LUA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, LA_Height, 0)).p)
                    local LLA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, -LA_Height, 0)).p)
                    local RA_Height = plr.Character["Right Arm"].Size.Y/2 - 0.2
                    local RUA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, RA_Height, 0)).p)
                    local RLA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, -RA_Height, 0)).p)
                    local LL_Height = plr.Character["Left Leg"].Size.Y/2 - 0.2
                    local LUL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, LL_Height, 0)).p)
                    local LLL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, -LL_Height, 0)).p)
                    local RL_Height = plr.Character["Right Leg"].Size.Y/2 - 0.2
                    local RUL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, RL_Height, 0)).p)
                    local RLL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, -RL_Height, 0)).p)
                    limbs.Head_Spine.From = Vector2.new(H.X, H.Y)
                    limbs.Head_Spine.To = Vector2.new(UT.X, UT.Y)
                    limbs.Spine.From = Vector2.new(UT.X, UT.Y)
                    limbs.Spine.To = Vector2.new(LT.X, LT.Y)
                    limbs.LeftArm.From = Vector2.new(LUA.X, LUA.Y)
                    limbs.LeftArm.To = Vector2.new(LLA.X, LLA.Y)
                    limbs.LeftArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                    limbs.LeftArm_UpperTorso.To = Vector2.new(LUA.X, LUA.Y)
                    limbs.RightArm.From = Vector2.new(RUA.X, RUA.Y)
                    limbs.RightArm.To = Vector2.new(RLA.X, RLA.Y)
                    limbs.RightArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                    limbs.RightArm_UpperTorso.To = Vector2.new(RUA.X, RUA.Y)
                    limbs.LeftLeg.From = Vector2.new(LUL.X, LUL.Y)
                    limbs.LeftLeg.To = Vector2.new(LLL.X, LLL.Y)
                    limbs.LeftLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                    limbs.LeftLeg_LowerTorso.To = Vector2.new(LUL.X, LUL.Y)
                    limbs.RightLeg.From = Vector2.new(RUL.X, RUL.Y)
                    limbs.RightLeg.To = Vector2.new(RLL.X, RLL.Y)
                    limbs.RightLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                    limbs.RightLeg_LowerTorso.To = Vector2.new(RUL.X, RUL.Y)
                    Visibility(true)
                else 
                    Visibility(false)
                end
            else 
                Visibility(false)
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for _, v in pairs(limbs) do pcall(function() v:Remove() end) end
                    if connection then connection:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, connection)
    end

    if R15 then
        UpdaterR15()
    else 
        UpdaterR6()
    end
end

local function startESP()
    cleanupESP()
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= Player.Name then
            DrawESP(v)
        end
    end
    local conn = game.Players.PlayerAdded:Connect(function(newplr)
        if newplr.Name ~= Player.Name then
            DrawESP(newplr)
        end
    end)
    table.insert(ALL_CONNECTIONS, conn)
end

--// Toggle integration (replace w1:Toggle with your own if needed)
w1:Toggle(
    "Skeleton ESP", -- Button Text
    "skeleton_esp_flag", -- Unique flag
    false,
    function(toggled)
        ESP_ON = toggled
        if ESP_ON then
            startESP()
        else
            cleanupESP()
        end
    end
)


-- Preview: https://cdn.discordapp.com/attachments/807887111667056680/820258191224340490/chams.png
-- Made by Blissful#4992, toggle/cleanup by Copilot

local Settings = {
    TeamCheck = true, -- Overules Color
    Red = Color3.fromRGB(255, 0, 0),
    Green = Color3.fromRGB(0, 255, 0),
    Color = Color3.fromRGB(255, 0, 0),
    TeamColor = false
}

--// Locals
local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

-- TRACK ALL DRAWING OBJECTS AND CONNECTIONS
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}

-- Toggle state (controlled by UI)
local ESP_ON = false

local function NewQuad(color)
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.PointA = Vector2.new(0,0)
    quad.PointB = Vector2.new(0,0)
    quad.PointC = Vector2.new(0,0)
    quad.PointD = Vector2.new(0,0)
    quad.Color = color
    quad.Filled = true
    quad.Thickness = 1
    quad.Transparency = 0.25
    table.insert(ALL_DRAWINGS, quad)
    return quad
end

local function Colorize(color, lib)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

-- FULL CLEANUP
local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
end

local function ESP(object, plr)
    local part = object
    --// Quads for 3D box (6)
    local quads = {
        quad1 = NewQuad(Settings.Color),
        quad2 = NewQuad(Settings.Color),
        quad3 = NewQuad(Settings.Color),
        quad4 = NewQuad(Settings.Color),
        quad5 = NewQuad(Settings.Color),
        quad6 = NewQuad(Settings.Color)
    }

    --// Updates ESP in render loop
    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESP_ON then
                for _, x in pairs(quads) do
                    x.Visible = false
                end
                if connection then connection:Disconnect() end
                return
            end
            if plr.Character ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild(object.Name) ~= nil then
                local partpos, onscreen = camera:WorldToViewportPoint(part.Position)
                if onscreen then
                    local size_X = part.Size.X/2
                    local size_Y = part.Size.Y/2
                    local size_Z = part.Size.Z/2

                    local Top1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, -size_Z)).p)
                    local Top2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, size_Z)).p)
                    local Top3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, size_Z)).p)
                    local Top4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, -size_Z)).p)

                    local Bottom1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, -size_Z)).p)
                    local Bottom2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, size_Z)).p)
                    local Bottom3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, size_Z)).p)
                    local Bottom4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, -size_Z)).p)

                    --// Top:
                    quads.quad1.PointA = Vector2.new(Top1.X, Top1.Y)
                    quads.quad1.PointB = Vector2.new(Top2.X, Top2.Y)
                    quads.quad1.PointC = Vector2.new(Top3.X, Top3.Y)
                    quads.quad1.PointD = Vector2.new(Top4.X, Top4.Y)

                    --//Bottom:
                    quads.quad2.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                    quads.quad2.PointB = Vector2.new(Bottom2.X, Bottom2.Y)
                    quads.quad2.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                    quads.quad2.PointD = Vector2.new(Bottom4.X, Bottom4.Y)

                    --//Sides:
                    quads.quad3.PointA = Vector2.new(Top1.X, Top1.Y)
                    quads.quad3.PointB = Vector2.new(Top2.X, Top2.Y)
                    quads.quad3.PointC = Vector2.new(Bottom2.X, Bottom2.Y)
                    quads.quad3.PointD = Vector2.new(Bottom1.X, Bottom1.Y)

                    quads.quad4.PointA = Vector2.new(Top2.X, Top2.Y)
                    quads.quad4.PointB = Vector2.new(Top3.X, Top3.Y)
                    quads.quad4.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                    quads.quad4.PointD = Vector2.new(Bottom2.X, Bottom2.Y)

                    quads.quad5.PointA = Vector2.new(Top3.X, Top3.Y)
                    quads.quad5.PointB = Vector2.new(Top4.X, Top4.Y)
                    quads.quad5.PointC = Vector2.new(Bottom4.X, Bottom4.Y)
                    quads.quad5.PointD = Vector2.new(Bottom3.X, Bottom3.Y)

                    quads.quad6.PointA = Vector2.new(Top4.X, Top4.Y)
                    quads.quad6.PointB = Vector2.new(Top1.X, Top1.Y)
                    quads.quad6.PointC = Vector2.new(Bottom1.X, Bottom1.Y)
                    quads.quad6.PointD = Vector2.new(Bottom4.X, Bottom4.Y)

                    if Settings.TeamCheck then
                        if plr.TeamColor == player.TeamColor then
                            Colorize(Settings.Green, quads)
                        else 
                            Colorize(Settings.Red, quads)
                        end
                    else 
                        Colorize(Settings.Color, quads)
                    end

                    if Settings.TeamColor then
                        Colorize(plr.TeamColor.Color, quads)
                    end

                    for _, x in pairs(quads) do
                        x.Visible = true
                    end
                else 
                    for _, x in pairs(quads) do
                        x.Visible = false
                    end
                end
            else 
                for _, x in pairs(quads) do
                    x.Visible = false
                end
                if game.Players:FindFirstChild(plr.Name) == nil then
                    if connection then connection:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, connection)
    end
    Updater()
end

local function startESP()
    cleanupESP()
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= player.Name then
            spawn(function()
                repeat wait() until v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("Head")
                for _, x in pairs(v.Character:GetChildren()) do
                    if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                        ESP(x, v)
                    end
                end
            end)
        end
    end
    local conn = game.Players.PlayerAdded:Connect(function(newplr)
        spawn(function()
            if newplr.Name ~= player.Name then
                repeat wait() until newplr.Character and newplr.Character:FindFirstChild("Humanoid") and newplr.Character:FindFirstChild("HumanoidRootPart") and newplr.Character.Humanoid.Health > 0 and newplr.Character:FindFirstChild("Head")
                for _, x in pairs(newplr.Character:GetChildren()) do
                    if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                        ESP(x, newplr)
                    end
                end
            end
        end)
    end)
    table.insert(ALL_CONNECTIONS, conn)
end

--// Toggle integration (Replace with your toggle UI if needed)
w1:Toggle(
    "Chams ESP", -- Button Text
    "chams_esp_flag", -- Unique flag
    false,
    function(toggled)
        ESP_ON = toggled
        if ESP_ON then
            startESP()
        else
            cleanupESP()
        end
    end
)

local workspace = game:GetService("Workspace")
local players = game:GetService("Players")
local player = players.LocalPlayer
local camera = workspace.CurrentCamera

--// Settings:
local on = false -- Controlled by toggle

local Box_Color = Color3.fromRGB(255, 0, 0)
local Box_Thickness = 2
local Box_Transparency = 1

local Tracers = true
local Tracer_Color = Color3.fromRGB(255, 0, 0)
local Tracer_Thickness = 2
local Tracer_Transparency = 1

local Shifter_Color = Color3.fromRGB(0, 255, 0)

local Autothickness = true

local Team_Check = true
local red = Color3.fromRGB(240, 20, 20)
local green = Color3.fromRGB(90, 215, 25)

-- FLAT TABLE OF ALL DRAWING OBJECTS
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}

local function Lerp(a, b, t)
    return a + (b - a) * t
end

local function NewLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(1, 1)
    line.Color = Box_Color
    line.Thickness = Box_Thickness
    line.Transparency = Box_Transparency
    table.insert(ALL_DRAWINGS, line)
    return line
end

local function NewQuad()
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.Color = Shifter_Color
    quad.Thickness = Box_Thickness
    quad.Filled = false
    quad.Transparency = Box_Transparency
    table.insert(ALL_DRAWINGS, quad)
    return quad
end

local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
end

local function createESPForPlayer(v)
    --// Lines for 3D box (12) and Tracer
    local lines = {
        line1 = NewLine(),
        line2 = NewLine(),
        line3 = NewLine(),
        line4 = NewLine(),
        line5 = NewLine(),
        line6 = NewLine(),
        line7 = NewLine(),
        line8 = NewLine(),
        line9 = NewLine(),
        line10 = NewLine(),
        line11 = NewLine(),
        line12 = NewLine(),
        Tracer = NewLine()
    }
    lines.Tracer.Color = Tracer_Color
    lines.Tracer.Thickness = Tracer_Thickness
    lines.Tracer.Transparency = Tracer_Transparency

    local Shifter = NewQuad()

    local debounce = 0
    local shifteroffset = 0

    local function ESP()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not on then
                for _, x in pairs(lines) do
                    x.Visible = false
                end
                Shifter.Visible = false
                if connection then connection:Disconnect() end
                return
            end

            if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Name ~= player.Name and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("Head") then
                local pos, vis = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local Scale = v.Character.Head.Size.Y/2
                    local Size = Vector3.new(2, 3, 1.5) * (Scale * 2)

                    local Top1 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z)).p)
                    local Top2 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z)).p)
                    local Top3 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, Size.Z)).p)
                    local Top4 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z)).p)

                    local Bottom1 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, -Size.Z)).p)
                    local Bottom2 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, Size.Z)).p)
                    local Bottom3 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, Size.Z)).p)
                    local Bottom4 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p)

                    -- Top:
                    lines.line1.From = Vector2.new(Top1.X, Top1.Y)
                    lines.line1.To = Vector2.new(Top2.X, Top2.Y)

                    lines.line2.From = Vector2.new(Top2.X, Top2.Y)
                    lines.line2.To = Vector2.new(Top3.X, Top3.Y)

                    lines.line3.From = Vector2.new(Top3.X, Top3.Y)
                    lines.line3.To = Vector2.new(Top4.X, Top4.Y)

                    lines.line4.From = Vector2.new(Top4.X, Top4.Y)
                    lines.line4.To = Vector2.new(Top1.X, Top1.Y)

                    -- Bottom:
                    lines.line5.From = Vector2.new(Bottom1.X, Bottom1.Y)
                    lines.line5.To = Vector2.new(Bottom2.X, Bottom2.Y)

                    lines.line6.From = Vector2.new(Bottom2.X, Bottom2.Y)
                    lines.line6.To = Vector2.new(Bottom3.X, Bottom3.Y)

                    lines.line7.From = Vector2.new(Bottom3.X, Bottom3.Y)
                    lines.line7.To = Vector2.new(Bottom4.X, Bottom4.Y)

                    lines.line8.From = Vector2.new(Bottom4.X, Bottom4.Y)
                    lines.line8.To = Vector2.new(Bottom1.X, Bottom1.Y)

                    -- Sides:
                    lines.line9.From = Vector2.new(Bottom1.X, Bottom1.Y)
                    lines.line9.To = Vector2.new(Top1.X, Top1.Y)

                    lines.line10.From = Vector2.new(Bottom2.X, Bottom2.Y)
                    lines.line10.To = Vector2.new(Top2.X, Top2.Y)

                    lines.line11.From = Vector2.new(Bottom3.X, Bottom3.Y)
                    lines.line11.To = Vector2.new(Top3.X, Top3.Y)

                    lines.line12.From = Vector2.new(Bottom4.X, Bottom4.Y)
                    lines.line12.To = Vector2.new(Top4.X, Top4.Y)

                    -- Tracer:
                    if Tracers then
                        local trace = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(0, -Size.Y, 0)).p)
                        lines.Tracer.From = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y)
                        lines.Tracer.To = Vector2.new(trace.X, trace.Y)
                        lines.Tracer.Visible = true
                    else
                        lines.Tracer.Visible = false
                    end

                    -- Teamcheck:
                    if Team_Check then
                        if v.TeamColor == player.TeamColor then
                            for _, x in pairs(lines) do x.Color = green end
                            Shifter.Color = red
                        else
                            for _, x in pairs(lines) do x.Color = red end
                            Shifter.Color = green
                        end
                    end

                    -- Shifter:
                    if debounce == 0 then
                        debounce = debounce + 1
                        spawn(function()
                            for i = 0, Size.Y, 0.1 do
                                shifteroffset = Lerp(shifteroffset, i, 0.5)
                                wait()
                            end
                            for i = shifteroffset, 0, -0.1 do
                                shifteroffset = Lerp(shifteroffset, i, 0.5)
                                wait()
                            end
                            for i = 0, -Size.Y, -0.1 do
                                shifteroffset = Lerp(shifteroffset, i, 0.5)
                                wait()
                            end
                            for i = shifteroffset, 0, 0.1 do
                                shifteroffset = Lerp(shifteroffset, i, 0.5)
                                wait()
                            end
                            debounce = 0
                        end)
                    end

                    local shifter1 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, shifteroffset, -Size.Z)).p)
                    local shifter2 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, shifteroffset, Size.Z)).p)
                    local shifter3 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, shifteroffset, Size.Z)).p)
                    local shifter4 = camera:WorldToViewportPoint((v.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, shifteroffset, -Size.Z)).p)

                    Shifter.PointA = Vector2.new(shifter1.X, shifter1.Y)
                    Shifter.PointB = Vector2.new(shifter2.X, shifter2.Y)
                    Shifter.PointC = Vector2.new(shifter3.X, shifter3.Y)
                    Shifter.PointD = Vector2.new(shifter4.X, shifter4.Y)
                    Shifter.Visible = true

                    -- Autothickness:
                    if Autothickness then
                        local distance = (player.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                        local value = math.clamp(1/distance*100, 0.1, 4)
                        for _, x in pairs(lines) do x.Thickness = value end
                        Shifter.Thickness = value
                    else
                        for _, x in pairs(lines) do x.Thickness = Box_Thickness end
                        Shifter.Thickness = Box_Thickness
                    end

                    for name, x in pairs(lines) do
                        if name ~= "Tracer" or Tracers then
                            x.Visible = true
                        end
                    end
                else
                    for _, x in pairs(lines) do x.Visible = false end
                    Shifter.Visible = false
                end
            else
                for _, x in pairs(lines) do x.Visible = false end
                Shifter.Visible = false
                if players:FindFirstChild(v.Name) == nil then
                    if connection then connection:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, connection)
    end
    ESP()
end

local function startESP()
    cleanupESP()
    for _, v in pairs(players:GetPlayers()) do
        if v ~= player then
            createESPForPlayer(v)
        end
    end
    local conn = players.PlayerAdded:Connect(function(newplr)
        if newplr ~= player then
            createESPForPlayer(newplr)
        end
    end)
    table.insert(ALL_CONNECTIONS, conn)
end

--// Toggle (REPLACE THIS WITH YOUR UI TOGGLE CALLBACK)
w1:Toggle(
    "ESP 3D Box", -- Button Text
    "esp_3d_box_flag", -- Unique flag
    false,
    function(toggled)
        on = toggled
        if on then
            startESP()
        else
            cleanupESP()
        end
    end
)


-- Corner Box ESP with Toggle/Cleanup (no logic/visual changes)
-- Original by Blissful#4992, toggle/cleanup by Copilot

local Settings = {
    Box_Color = Color3.fromRGB(255, 0, 0),
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true
}

local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera

-- Tracking tables and toggle state
local ALL_DRAWINGS = {}
local ALL_CONNECTIONS = {}
local ALL_PARTS = {}
local ESP_ON = false

local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    table.insert(ALL_DRAWINGS, line)
    return line
end

local function Vis(lib, state)
    for _, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for _, v in pairs(lib) do
        v.Color = color
    end
end

local Black = Color3.fromRGB(0, 0, 0)

local function Rainbow(lib, delay)
    coroutine.wrap(function()
        while ESP_ON do
            for hue = 0, 1, 1/30 do
                local color = Color3.fromHSV(hue, 0.6, 1)
                Colorize(lib, color)
                wait(delay)
                if not ESP_ON then return end
            end
        end
    end)()
end

local function cleanupESP()
    for _, obj in ipairs(ALL_DRAWINGS) do
        pcall(function() obj.Visible = false end)
        pcall(function() obj:Remove() end)
    end
    ALL_DRAWINGS = {}
    for _, conn in ipairs(ALL_CONNECTIONS) do
        pcall(function() conn:Disconnect() end)
    end
    ALL_CONNECTIONS = {}
    for _, part in ipairs(ALL_PARTS) do
        pcall(function() part:Destroy() end)
    end
    ALL_PARTS = {}
end

local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }
    Rainbow(Library, 0.15)
    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)
    table.insert(ALL_PARTS, oripart)

    local function Updater()
        local c
        c = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESP_ON then
                Vis(Library, false)
                if c then c:Disconnect() end
                return
            end
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)
                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y*1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

                    if Settings.Team_Check then
                        if plr.TeamColor == Player.TeamColor then
                            Colorize(Library, Color3.fromRGB(0, 255, 0))
                        else 
                            Colorize(Library, Color3.fromRGB(255, 0, 0))
                        end
                    end

                    if Settings.Team_Color then
                        Colorize(Library, plr.TeamColor.Color)
                    end

                    local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
                    local offset = math.clamp(1/ratio*750, 2, 300)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

                    Vis(Library, true)

                    if Settings.Autothickness then
                        local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                        local value = math.clamp(1/distance*100, 1, 4)
                        for _, x in pairs(Library) do
                            x.Thickness = value
                        end
                    else 
                        for _, x in pairs(Library) do
                            x.Thickness = Settings.Box_Thickness
                        end
                    end
                else 
                    Vis(Library, false)
                end
            else 
                Vis(Library, false)
                if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
                    for _, v in pairs(Library) do
                        pcall(function() v:Remove() end)
                    end
                    pcall(function() oripart:Destroy() end)
                    if c then c:Disconnect() end
                end
            end
        end)
        table.insert(ALL_CONNECTIONS, c)
    end
    coroutine.wrap(Updater)()
end

local function startESP()
    cleanupESP()
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= Player.Name then
          coroutine.wrap(Main)(v)
        end
    end
    local conn = game:GetService("Players").PlayerAdded:Connect(function(newplr)
        coroutine.wrap(Main)(newplr)
    end)
    table.insert(ALL_CONNECTIONS, conn)
end

--// Toggle integration (replace w1:Toggle with your UI if needed)
w1:Toggle(
    "Corner Box ESP", -- Button Text
    "cornerbox_esp_flag", -- Unique flag
    false,
    function(toggled)
        ESP_ON = toggled
        if ESP_ON then
            startESP()
        else
            cleanupESP()
        end
    end
)



w1:Button(
    "Destroy GUI",
    function()
        for i, v in pairs(game.CoreGui:GetChildren()) do
            if v:FindFirstChild("Top") then
                v:Destroy()
            end
        end
    end
) -- Text, Callback
